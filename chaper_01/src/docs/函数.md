### 函数声明（函数定义）

> 1. 函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。
> 2. 因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。
> 3. 编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don't Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。
> 4. 当函数执行到代码块最后一行}之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。

Go语言里面拥三种类型的函数：
> 1. 普通的带有名字的函数
> 2. 匿名函数或者 lambda 函数
> 3. 方法

#### 普通函数声明（定义）

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。
```
func 函数名(形式参数列表)(返回值列表){
    函数体
}
```

> 形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：
```cgo
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // "5"
```
> x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。

> 如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。

正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：
```cgo
func f(i, j, k int, s, t string) { /* ... */ }
func f(i int, j int, k int, s string, t string) { /* ... */ }
```

下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符_可以强调某个参数未被使用。
```cgo
func add(x int, y int) int {return x + y}
func sub(x, y int) (z int) { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0 }
fmt.Printf("%T\n", add) // "func(int, int) int"
fmt.Printf("%T\n", sub) // "func(int, int) int"
fmt.Printf("%T\n", first) // "func(int, int) int"
fmt.Printf("%T\n", zero) // "func(int, int) int"
```
> 1. 函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。
> 2. 每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。
> 3. 在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。

#### 函数的返回值

> Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：
```cgo
conn, err := connectToNetwork()
```
> 在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。

Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。

##### 1) 同一种类型返回值

> 如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。

使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：
```cgo
func typedTwoValues() (int, int) {
    return 1, 2
}
func main() {
    a, b := typedTwoValues()
    fmt.Println(a, b)
}
代码输出结果：
1 2

纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。
```

##### 2) 带有变量名的返回值

> 1. Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。
> 2. 命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。

下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：
```cgo
func namedRetValues() (a, b int) {

    a = 1
    b = 2

    return
}
代码说明如下：
第 92 行，对两个整型返回值进行命名，分别为 a 和 b。
第 94 行和第 95 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。
第 97 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。
func namedRetValues() (a, b int) {
    a = 1

    return a, 2
}
```

**提示**:
> 同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误
```cgo
func namedRetValues() (a, b int, int)
编译报错提示：
mixed named and unnamed function parameters

意思是：在函数参数中混合使用了命名和非命名参数。
```

#### 调用函数

> 1. 函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
> 2. 函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。
```cgo
Go语言的函数调用格式如下：
返回值变量列表 = 函数名(参数列表)

下面是对各个部分的说明：
1. 函数名：需要调用的函数名。
2. 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。
3. 返回值变量列表：多个返回值使用逗号分隔。

例如，加法函数调用样式如下：
result := add(1,1)
```

#### Go语言将秒转换为具体的时间

在本例中，使用一个数值表示时间中的“秒”值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。
```cgo
package main

import "fmt"

const (
    // 定义每分钟的秒数
    SecondsPerMinute = 60

    // 定义每小时的秒数
    SecondsPerHour = SecondsPerMinute * 60

    // 定义每天的秒数
    SecondsPerDay = SecondsPerHour * 24
)

// 将传入的“秒”解析为3种时间单位
func resolveTime(seconds int) (day int, hour int, minute int) {

    day = seconds / SecondsPerDay
    hour = seconds / SecondsPerHour
    minute = seconds / SecondsPerMinute

    return
}

func main() {

    // 将返回值作为打印参数
    fmt.Println(resolveTime(1000))

    // 只获取消息和分钟
    _, hour, minute := resolveTime(18000)
    fmt.Println(hour, minute)

    // 只获取天
    day, _, _ := resolveTime(90000)
    fmt.Println(day)
}

代码输出结果：
0 0 16
5 300
1
```

#### 函数中的参数传递效果测试

> Go语言中传入与返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和 map 等引用型对象在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。

下面通过一个例子来详细了解Go语言的参数值传递，完整的示例代码如下所示：

```cgo
package main

import "fmt"

// 用于测试值传递效果的结构体
type Data struct {
    complax []int // 测试切片在参数传递中的效果

    instance InnerData // 实例分配的innerData

    ptr *InnerData // 将ptr声明为InnerData的指针类型
}

// 代表各种结构体字段
type InnerData struct {
    a int
}

// 值传递测试函数
func passByValue(inFunc Data) Data {

    // 输出参数的成员情况
    fmt.Printf("inFunc value: %+v\n", inFunc)

    // 打印inFunc的指针
    fmt.Printf("inFunc ptr: %p\n", &inFunc)

    return inFunc
}

func main() {

    // 准备传入函数的结构
    in := Data{
        complax: []int{1, 2, 3},
        instance: InnerData{
            5,
        },

        ptr: &InnerData{1},
    }

    // 输入结构的成员情况
    fmt.Printf("in value: %+v\n", in)

    // 输入结构的指针地址
    fmt.Printf("in ptr: %p\n", &in)

    // 传入结构体，返回同类型的结构体
    out := passByValue(in)

    // 输出结构的成员情况
    fmt.Printf("out value: %+v\n", out)

    // 输出结构的指针地址
    fmt.Printf("out ptr: %p\n", &out)
}
```
#### 1) 测试数据类型

> 为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：
```cgo
// 用于测试值传递效果的结构体
type Data struct {
    Complax []int    // 测试切片在参数传递中的效果

    Instance InnerData    // 实例分配的innerData

    Ptr *InnerData    // 将ptr声明为InnerData的指针类型
}

// 代表各种结构体字段
type InnerData struct {
    A int
}

代码说明如下：
第 256 行，将 Data 声明为结构体类型，结构体是拥有多个字段的复杂结构。
第 257 行，complax 为整型切片类型，切片是一种动态类型，内部以指针存在。
第 259 行，instance 成员以 InnerData 类型作为 Data 的成员。
第 261 行，将 ptr 声明为 InnerData 的指针类型。
第 265 行，声明一个内嵌的结构 InnerData。
```
#### 2) 值传递的测试函数

> 示例代码中定义的 passByValue() 函数用于值传递的测试，该函数的参数和返回值都是 Data 类型，在调用过程中，Data 的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量，代码如下：
```cgo
// 值传递测试函数
func passByValue(inFunc Data) Data {

    // 输出参数的成员情况
    fmt.Printf("inFunc value: %+v\n", inFunc)

    // 打印inFunc的指针
    fmt.Printf("inFunc ptr: %p\n", &inFunc)

    return inFunc
}
代码说明如下：
第 284 行，使用格式化的%+v动词输出 inFunc 变量的详细结构，以便观察 Data 结构在传递前后内部数值的变化情况。
第 287 行，打印传入参数 inFunc 的指针地址，在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。
第 289 行，将传入的变量作为返回值返回，返回的过程将发生值复制。
```
#### 3) 测试流程
> 测试流程会准备一个 Data 格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针，通过调用测试函数，传入 Data 结构数据，并获得返回值，对比输入和输出后的 Data 结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：
```cgo
// 准备传入函数的结构
in := Data{
    complax: []int{1, 2, 3},
    instance: InnerData{
            5,
    },

    ptr: &InnerData{1},
}

// 输入结构的成员情况
fmt.Printf("in value: %+v\n", in)

// 输入结构的指针地址
fmt.Printf("in ptr: %p\n", &in)

// 传入结构体, 返回同类型的结构体
out := passByValue(in)

// 输出结构的成员情况
fmt.Printf("out value: %+v\n", out)

// 输出结构的指针地址
fmt.Printf("out ptr: %p\n", &out)

运行代码，输出结果为：
示例程序代码在,demo01下的func_demo passByValue.go
in ptr: 0xc0000a0c30
inFunc value {Complax:[1 2 3] Instance:{A:6} Ptr:0xc0000ba290}
inFunc ptr: 0xc0000a0cc0
out value: {Complax:[1 2 3] Instance:{A:6} Ptr:0xc0000ba290}
out ptr: 0xc0000a0c90

```

>从运行结果中发现：
>> 1. 所有的 Data 结构的指针地址都发生了变化，意味着所有的结构都是一块新的内存，无论是将 Data 结构传入函数内部，还是通过函数返回值传回 Data 都会发生复制行为。
>> 2. 所有的 Data 结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。
>> 3. Data 结构的 ptr 成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。

### 函数变量——把函数作为值保存到变量中

> 在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：
```cgo
package main

import (
    "fmt"
)

func fire() {
    fmt.Println("fire")
}

func main() {

    var f func()

    f = fire

    f()
}
```

### 字符串的链式处理——操作与数据分离的设计技巧

> 使用 SQL 语言从数据库中获取数据时，可以对原始数据进行排序（sort by）、分组（group by）和去重（distinct）等操作，SQL 将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。

> 对数据的操作进行多步骤的处理被称为链式处理，本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。

```cgo
package main

import (
    "fmt"
    "strings"
)

// 字符串处理函数，传入字符串切片和处理链
func StringProccess(list []string, chain []func(string) string) {

    // 遍历每一个字符串
    for index, str := range list {

        // 第一个需要处理的字符串
        result := str

        // 遍历每一个处理链
        for _, proc := range chain {

            // 输入一个字符串进行处理，返回数据作为下一个处理链的输入。
            result = proc(result)
        }

        // 将结果放回切片
        list[index] = result
    }
}

// 自定义的移除前缀的处理函数
func removePrefix(str string) string {

    return strings.TrimPrefix(str, "go")
}

func main() {

    // 待处理的字符串列表
    list := []string{
        "go scanner",
        "go parser",
        "go compiler",
        "go printer",
        "go formater",
    }

    // 处理函数链
    chain := []func(string) string{
        removePrefix,
        strings.TrimSpace,
        strings.ToUpper,
    }

    // 处理字符串
    StringProccess(list, chain)

    // 输出处理好的字符串
    for _, str := range list {
        fmt.Println(str)
    }

}
```

提示
>链式处理器是一种常见的编程设计，Netty 是使用 Java 语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty 中就有类似的链式处理器的设计。

> Netty 可以使用类似的处理链对封包进行收发编码及处理，Netty 的开发者可以分为 3 种：
>> 1. 第一种是 Netty 底层开发者；
>> 2. 第二种是每个处理环节的开发者；
>> 3. 第三种是业务实现者。在实际开发环节中，后两种开发者往往是同一批开发者，链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。

### 匿名函数——没有函数名字的函数

> Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。

> 匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。

#### 定义一个匿名函数
匿名函数的定义格式如下：
```cgo
func(参数列表)(返回参数列表){
    函数体
}
```
匿名函数的定义就是没有名字的普通函数定义。
##### 1) 在定义时调用匿名函数
匿名函数可以在声明后调用，例如：
```cgo
func(data int) {
    fmt.Println("hello", data)
}(100)

注意第460行}后的(100)，表示对匿名函数进行调用，传递参数为 100。
```
##### 2) 将匿名函数赋值给变量
匿名函数可以被赋值，例如：
```cgo
// 将匿名函数体保存到f()中
f := func(data int) {
    fmt.Println("hello", data)
}
// 使用f()调用
f(100)

匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。
```
#### 匿名函数用作回调函数
下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：

```cgo
package main

import (
    "fmt"
)

// 遍历切片的每个元素, 通过给定函数进行元素访问
func visit(list []int, f func(int)) {

    for _, v := range list {
        f(v)
    }
}

func main() {

    // 使用匿名函数打印切片内容
    visit([]int{1, 2, 3, 4}, func(v int) {
        fmt.Println(v)
    })
}

代码说明如下：
第 487 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
第 497 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。
第 498～499 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。
```
匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下：
```cgo
func TrimFunc(s string, f func(rune) bool) string {
    return TrimRightFunc(TrimLeftFunc(s, f), f)
}
```
### 使用匿名函数实现操作封装
下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下：
```cgo
package main

import (
    "flag"
    "fmt"
)

var skillParam = flag.String("skill", "", "skill to perform")

func main() {

    flag.Parse()

    var skill = map[string]func(){
        "fire": func() {
            fmt.Println("chicken fire")
        },
        "run": func() {
            fmt.Println("soldier run")
        },
        "fly": func() {
            fmt.Println("angel fly")
        },
    }

    if f, ok := skill[*skillParam]; ok {
        f()
    } else {
        fmt.Println("skill not found")
    }

}

代码说明如下：
第 523 行，定义命令行参数 skill，从命令行输入 --skill 可以将=后的字符串传入 skillParam 指针变量。
第 527 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。
第 529 行，定义一个从字符串映射到 func() 的 map，然后填充这个 map。
第 530～538 行，初始化 map 的键值对，值为匿名函数。
第 541 行，skillParam 是一个 *string 类型的指针变量，使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
第 544 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。
```









