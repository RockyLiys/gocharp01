### 函数声明（函数定义）

> 1. 函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。
> 2. 因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。
> 3. 编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don't Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。
> 4. 当函数执行到代码块最后一行}之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。

Go语言里面拥三种类型的函数：
> 1. 普通的带有名字的函数
> 2. 匿名函数或者 lambda 函数
> 3. 方法

#### 普通函数声明（定义）

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。
```
func 函数名(形式参数列表)(返回值列表){
    函数体
}
```

> 形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：
```cgo
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // "5"
```
> x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。

> 如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。

正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：
```cgo
func f(i, j, k int, s, t string) { /* ... */ }
func f(i int, j int, k int, s string, t string) { /* ... */ }
```

下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符_可以强调某个参数未被使用。
```cgo
func add(x int, y int) int {return x + y}
func sub(x, y int) (z int) { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0 }
fmt.Printf("%T\n", add) // "func(int, int) int"
fmt.Printf("%T\n", sub) // "func(int, int) int"
fmt.Printf("%T\n", first) // "func(int, int) int"
fmt.Printf("%T\n", zero) // "func(int, int) int"
```
> 1. 函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。
> 2. 每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。
> 3. 在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。

#### 函数的返回值

> Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：
```cgo
conn, err := connectToNetwork()
```
> 在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。

Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。

##### 1) 同一种类型返回值

> 如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。

使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：
```cgo
func typedTwoValues() (int, int) {
    return 1, 2
}
func main() {
    a, b := typedTwoValues()
    fmt.Println(a, b)
}
代码输出结果：
1 2

纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。
```

##### 2) 带有变量名的返回值

> 1. Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。
> 2. 命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。

下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：
```cgo
func namedRetValues() (a, b int) {

    a = 1
    b = 2

    return
}
代码说明如下：
第 92 行，对两个整型返回值进行命名，分别为 a 和 b。
第 94 行和第 95 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。
第 97 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。
func namedRetValues() (a, b int) {
    a = 1

    return a, 2
}
```

**提示**:
> 同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误
```cgo
func namedRetValues() (a, b int, int)
编译报错提示：
mixed named and unnamed function parameters

意思是：在函数参数中混合使用了命名和非命名参数。
```

#### 调用函数

> 1. 函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
> 2. 函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。
```cgo
Go语言的函数调用格式如下：
返回值变量列表 = 函数名(参数列表)

下面是对各个部分的说明：
1. 函数名：需要调用的函数名。
2. 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。
3. 返回值变量列表：多个返回值使用逗号分隔。

例如，加法函数调用样式如下：
result := add(1,1)
```

#### Go语言将秒转换为具体的时间

在本例中，使用一个数值表示时间中的“秒”值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。
```cgo
package main

import "fmt"

const (
    // 定义每分钟的秒数
    SecondsPerMinute = 60

    // 定义每小时的秒数
    SecondsPerHour = SecondsPerMinute * 60

    // 定义每天的秒数
    SecondsPerDay = SecondsPerHour * 24
)

// 将传入的“秒”解析为3种时间单位
func resolveTime(seconds int) (day int, hour int, minute int) {

    day = seconds / SecondsPerDay
    hour = seconds / SecondsPerHour
    minute = seconds / SecondsPerMinute

    return
}

func main() {

    // 将返回值作为打印参数
    fmt.Println(resolveTime(1000))

    // 只获取消息和分钟
    _, hour, minute := resolveTime(18000)
    fmt.Println(hour, minute)

    // 只获取天
    day, _, _ := resolveTime(90000)
    fmt.Println(day)
}

代码输出结果：
0 0 16
5 300
1
```

#### 函数中的参数传递效果测试

> Go语言中传入与返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和 map 等引用型对象在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。

下面通过一个例子来详细了解Go语言的参数值传递，完整的示例代码如下所示：

```cgo
package main

import "fmt"

// 用于测试值传递效果的结构体
type Data struct {
    complax []int // 测试切片在参数传递中的效果

    instance InnerData // 实例分配的innerData

    ptr *InnerData // 将ptr声明为InnerData的指针类型
}

// 代表各种结构体字段
type InnerData struct {
    a int
}

// 值传递测试函数
func passByValue(inFunc Data) Data {

    // 输出参数的成员情况
    fmt.Printf("inFunc value: %+v\n", inFunc)

    // 打印inFunc的指针
    fmt.Printf("inFunc ptr: %p\n", &inFunc)

    return inFunc
}

func main() {

    // 准备传入函数的结构
    in := Data{
        complax: []int{1, 2, 3},
        instance: InnerData{
            5,
        },

        ptr: &InnerData{1},
    }

    // 输入结构的成员情况
    fmt.Printf("in value: %+v\n", in)

    // 输入结构的指针地址
    fmt.Printf("in ptr: %p\n", &in)

    // 传入结构体，返回同类型的结构体
    out := passByValue(in)

    // 输出结构的成员情况
    fmt.Printf("out value: %+v\n", out)

    // 输出结构的指针地址
    fmt.Printf("out ptr: %p\n", &out)
}
```












