### 容器
* 变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”
* 本章将以实用为目的，详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。本章既可以作为教程，也可以作为字典，以方便开发者日常的查询和应用
> 其它语言中的容器
> * C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。
> * C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。
> * C# 语言通过 .NET 框架提供，如 List 对应数组，LinkedList 对应双链表，Dictionary 对应映射。
> * Lua 语言的 table 实现了数组和映射的功能，Lua 语言默认没有双链表支持。

#### 一维数组
*  数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组
* 和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 slice 工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用

##### 数组的声明
> var 数组变量名 [元素数量]Type

语法说明如下所示：
> * 数组变量名：数组声明及使用时的变量名。
> * 元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
> * Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

* 数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数

```
var a [3]int             // 定义三个整数的数组
fmt.Println(a[0])        // 打印第一个元素
fmt.Println(a[len(a)-1]) // 打印最后一个元素

// 打印索引和元素
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// 仅打印元素
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```
* 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组
```
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```
* 在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为
```
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```
* 数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定
```
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int
```
##### 比较两个数组是否相等
* 如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（== 和 !=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译
```
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int
```
##### 遍历数组——访问每一个数组元素
* 遍历数组也和遍历切片类似
```
var team [3]string
team[0] = "hammer"
team[1] = "soldier"
team[2] = "mum"

for k, v := range team {
    fmt.Println(k, v)
}

代码输出结果：
0 hammer
1 soldier
2 mum
```
#### 多维数组
* Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据
* 声明多维数组的语法
> var array_name [size1][size2]...[sizen] array_type
* 其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。
 
* 二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的
```
// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
var array [4][2]int
// 使用数组字面量来声明并初始化一个二维整型数组
array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化数组中索引为 1 和 3 的元素
array = [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化数组中指定的元素
array = [4][2]int{1: {0: 20}, 3: {1: 41}}
```
* 为了访问单个元素，需要反复组合使用[ ]方括号
```
// 声明一个 2×2 的二维整型数组
var array [2][2]int
// 设置每个元素的整型值
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
```
* 只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型
```
// 声明两个二维整型数组
var array1 [2][2]int
var array2 [2][2]int
// 为array2的每个元素赋值
array2[0][0] = 10
array2[0][1] = 20
array2[1][0] = 30
array2[1][1] = 40
// 将 array2 的值复制给 array1
array1 = array2
```
* 因为数组中每个元素都是一个值，所以可以独立复制某个维度
```
// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里
var array3 [2]int = array1[1]
// 将数组中指定的整型值复制到新的整型变量里
var value int = array1[1][0]
```
### 切片
* 切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内
* Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小

#### 从数组或切片生成新的切片
* 切片默认指向一段连续内存区域，可以是数组，也可以是切片本身
* 从连续内存区域生成切片是常见的操作
> slice [开始位置 : 结束位置]

语法说明如下：
> * slice：表示目标切片对象；
> * 开始位置：对应目标切片对象的索引；
> * 结束位置：对应目标切片的结束索引

从数组生成切片
```
var a  = [3]int{1, 2, 3}
fmt.Println(a, a[1:2])

其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：
[1 2 3]  [2]
其中 [2] 就是 a[1:2] 切片操作的结果

```
从数组或切片生成新的切片拥有如下特性
> * 取出的元素数量为：结束位置 - 开始位置；
> * 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
> * 当缺省开始位置时，表示从连续区域开头到结束位置；
> * 当缺省结束位置时，表示从开始位置到整个连续区域末尾；
> * 两者同时缺省时，与切片本身等效；
> * 两者同时为 0 时，等效于空切片，一般用于切片复位 

* 根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错

通过实例来熟悉切片的特性
* 切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片
```
var highRiseBuilding [30]int

for i := 0; i < 30; i++ {
        highRiseBuilding[i] = i + 1
}

// 区间
fmt.Println(highRiseBuilding[10:15])

// 中间到尾部的所有元素
fmt.Println(highRiseBuilding[20:])

// 开头到中间指定位置的所有元素
fmt.Println(highRiseBuilding[:2])
代码输出如下：
[11 12 13 14 15]
[21 22 23 24 25 26 27 28 29 30]
[1 2]
```
* 切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大

表示原有的切片
* 生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的
```
a := [...]int{1, 2, 3}
fmt.Println(a[:])


[1 2 3]
```
* a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致

重置切片，清空拥有的元素
* 把切片的开始和结束位置都设为 0 时，生成的切片将变空
```
a := [...]int{1, 2, 3}
fmt.Println(a[0:0])

[]
```

#### 直接声明新的切片
* 除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明
> var name []Type
* 其中 name 表示切片的变量名，Type 表示切片对应的元素类型
```
// 声明字符串切片
var strList []string

// 声明整型切片
var numList []int

// 声明一个空切片
var numListEmpty = []int{}

// 输出3个切片
fmt.Println(strList, numList, numListEmpty)

// 输出3个切片大小
fmt.Println(len(strList), len(numList), len(numListEmpty))

// 切片判定空的结果
fmt.Println(strList == nil)
fmt.Println(numList == nil)
fmt.Println(numListEmpty == nil)

代码输出结果：
[] [] []
0 0 0
true
true
false
```
* 切片是动态结构，只能与 nil 判定相等，不能互相判定相等
* 声明新的切片后，可以使用 append() 函数向切片中添加元素

#### 使用 make() 函数构造切片
* 如果需要动态地创建一个切片，可以使用 make() 内建函数
> make( []Type, size, cap )
* 其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题
```
a := make([]int, 2)
b := make([]int, 2, 10)

fmt.Println(a, b)
fmt.Println(len(a), len(b))
代码输出如下：
[0 0] [0 0]
2 2
```
* 其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素
* 容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2
>温馨提示
> * 使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作

#### append()为切片添加元素
```
var a []int
a = append(a, 1) // 追加1个元素
a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
```
* 不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变
* 切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充
```
var numbers []int

for i := 0; i < 10; i++ {
    numbers = append(numbers, i)
    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)
}

代码输出如下：
len: 1  cap: 1 pointer: 0xc0420080e8
len: 2  cap: 2 pointer: 0xc042008150
len: 3  cap: 4 pointer: 0xc04200e320
len: 4  cap: 4 pointer: 0xc04200e320
len: 5  cap: 8 pointer: 0xc04200c200
len: 6  cap: 8 pointer: 0xc04200c200
len: 7  cap: 8 pointer: 0xc04200c200
len: 8  cap: 8 pointer: 0xc04200c200
len: 9  cap: 16 pointer: 0xc042074000
len: 10  cap: 16 pointer: 0xc042074000
```
* 通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap

除了在切片的尾部追加，我们还可以在切片的开头添加元素
```
var a = []int{1,2,3}
a = append([]int{0}, a...) // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
```
* 在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多
* 因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素
```
var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```
* 每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中

### copy()：切片复制（切片拷贝）
* Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制
* copy() 函数的使用格式
> copy( destSlice, srcSlice []T) int
* 其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数
```
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
```
* 虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题
```
package main

import "fmt"

func main() {

    // 设置元素数量为1000
    const elementCount = 1000

    // 预分配足够多的元素切片
    srcData := make([]int, elementCount)

    // 将切片赋值
    for i := 0; i < elementCount; i++ {
        srcData[i] = i
    }

    // 引用切片数据
    refData := srcData

    // 预分配足够多的元素切片
    copyData := make([]int, elementCount)
    // 将数据复制到新的切片空间中
    copy(copyData, srcData)

    // 修改原始数据的第一个元素
    srcData[0] = 999

    // 打印引用切片的第一个元素
    fmt.Println(refData[0])

    // 打印复制切片的第一个和最后一个元素
    fmt.Println(copyData[0], copyData[elementCount-1])

    // 复制原始数据从4到6(不包含)
    copy(copyData, srcData[4:6])

    for i := 0; i < 5; i++ {
        fmt.Printf("%d ", copyData[i])
    }
}
```

#### 从切片中删除元素
* Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快
##### 从开头位置删除
```
删除开头的元素可以直接移动数据指针：
格式化复制
a = []int{1, 2, 3}
a = a[1:] // 删除开头1个元素
a = a[N:] // 删除开头N个元素
也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：
格式化复制
a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
还可以用 copy() 函数来删除开头的元素：
a = []int{1, 2, 3}
a = a[:copy(a, a[1:])] // 删除开头1个元素
a = a[:copy(a, a[N:])] // 删除开头N个元素
```
##### 从中间位置删除
* 对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：
```
a = []int{1, 2, 3, ...}
a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素
a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素
```
##### 从尾部删除
```
a = []int{1, 2, 3}
a = a[:len(a)-1] // 删除尾部1个元素
a = a[:len(a)-N] // 删除尾部N个元素
```
删除切片指定位置的元素
```

package main

import "fmt"

func main() {
    seq := []string{"a", "b", "c", "d", "e"}

    // 指定删除位置
    index := 2

    // 查看删除位置之前的元素和之后的元素
    fmt.Println(seq[:index], seq[index+1:])

    // 将删除点前后的元素连接起来
    seq = append(seq[:index], seq[index+1:]...)

    fmt.Println(seq)
}
代码输出结果：
[a b] [d e]
[a b d e]
```
* Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来
* 连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）


#### range关键字：循环迭代切片
* 通过前面的学习我们了解到切片其实就是多个相同类型元素的连续集合，既然切片是一个集合，那么我们就可以迭代其中的元素，Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素
```
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 迭代每一个元素，并显示其值
for index, value := range slice {
    fmt.Printf("Index: %d Value: %d\n", index, value)
}
```
* 关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环

```
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 从第三个元素开始迭代每个元素
for index := 2; index < len(slice); index++ {
    fmt.Printf("Index: %d Value: %d\n", index, slice[index])
}
输出结果为：
Index: 2 Value: 30
Index: 3 Value: 40
```
* range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等


### map(映射)
* Go语言中 map 是一种特殊的数据结构，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value
* map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等

#### map 概念
* map 是引用类型，可以使用如下方式声明
> var mapname map[keytype]valuetype

其中：
> * mapname 为 map 的变量名。
> * keytype 为键类型。
> * valuetype 是键对应的值类型。
* 提示：[keytype] 和 valuetype 之间允许有空格。
* 在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目

```
package main
import "fmt"

func main() {
    var mapLit map[string]int
    //var mapCreated map[string]float32
    var mapAssigned map[string]int
    mapLit = map[string]int{"one": 1, "two": 2}
    mapCreated := make(map[string]float32)
    mapAssigned = mapLit
    mapCreated["key1"] = 4.5
    mapCreated["key2"] = 3.14159
    mapAssigned["two"] = 3
    fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])
    fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])
    fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])
    fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])
}
输出结果：
Map literal at "one" is: 1
Map created at "key2" is: 3.14159
Map assigned at "two" is: 3
Map literal at "ten" is: 0
```
* mapLit 演示了使用{key1: value1, key2: value2}的格式来初始化 map ，就像数组和结构体一样

















