### 结构体（struct）
> Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。

> Go 语言中的类型可以被实例化，使用new或&构造的类型实例的类型是类型的指针。

结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：
> 1. 字段拥有自己的类型和值。
> 2. 字段名必须唯一。
> 3. 字段的类型也可以是结构体，甚至是字段所在结构体的类型。

##### **关于 Go 语言的类（class）**
> Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。

> Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。

> Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。

#### 结构体定义
> Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。

结构体成员也可以称为“字段”，这些字段有以下特性：
> 1. 字段拥有自己的类型和值；
> 2. 字段名必须唯一；
> 3. 字段的类型也可以是结构体，甚至是字段所在结构体的类型。

> 使用关键字 type 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。

结构体的定义格式如下：

```cgo
type 类型名 struct {
    字段1 字段1类型
    字段2 字段2类型
    …
}
```
对各个部分的说明：
> 1. 类型名：标识自定义结构体的名称，在同一个包内不能重复。
> 2. struct{}：表示结构体类型，type 类型名 struct{}可以理解为将 struct{} 结构体定义为类型名的类型。
> 3. 字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。
> 4. 字段1类型、字段2类型……：表示结构体各个字段的类型。

使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：
```cgo
type Point struct {
    X int
    Y int
}
```
同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：
```cgo
type Color struct {
    R, G, B byte
}
```

结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，我们将在下一节《实例化结构体》中详细为大家介绍。

#### 实例化结构体——为结构体分配内存并初始化
> 结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。

> 实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。

> Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。

#### 基本的实例化形式
> 结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。

基本实例化格式如下：
```cgo
var ins T
```
其中，T 为结构体类型，ins 为结构体的实例。

用结构体表示的点结构（Point）的实例化过程请参见下面的代码：
```cgo
type Point struct {
    X int
    Y int
}

var p Point
p.X = 10
p.Y = 20
```
在例子中，使用.来访问结构体的成员变量，如p.X和p.Y等，结构体成员变量的赋值方法与普通变量一致。

#### 创建指针类型的结构体
> Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。

使用 new 的格式如下：
```cgo
ins := new(T)
```
其中：
> 1. T 为类型，可以是结构体、整型、字符串等。
> 2. ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。

Go语言让我们可以像访问普通结构体一样使用.来访问结构体指针的成员。

下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：
```cgo
type Player struct{
    Name string
    HealthPoint int
    MagicPoint int
}

tank := new(Player)
tank.Name = "Canon"
tank.HealthPoint = 300
```
经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。

##### Go语言和 C/C++
> 在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用->操作符。

> 在Go语言中，访问结构体指针的成员变量时可以继续使用.，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。

#### 取结构体的地址实例化
> 在Go语言中，对结构体进行&取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：
```cgo
ins := &T{}
```
其中：
> 1. T 表示结构体类型。
> 2. ins 为结构体的实例，类型为 *T，是指针类型。

下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：
```cgo
type Command struct {
    Name    string    // 指令名称
    Var     *int      // 指令绑定的变量
    Comment string    // 指令的注释
}

var version int = 1

cmd := &Command{}
cmd.Name = "version"
cmd.Var = &version
cmd.Comment = "show version"


代码说明如下：
第 131 行，定义 Command 结构体，表示命令行指令
第 133 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步。
第 137 行，命令绑定的目标整型变量：版本号。
第 139 行，对结构体取地址实例化。
第 140～142 行，初始化成员字段。
```
取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下：
```cgo
func newCommand(name string, varref *int, comment string) *Command {
    return &Command{
        Name:    name,
        Var:     varref,
        Comment: comment,
    }
}

cmd = newCommand(
    "version",
    &version,
    "show version",
)
```
### 初始化结构体的成员变量
> 结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。

#### 使用“键值对”初始化结构体
>结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。

>键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。

>结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 ""（空字符串）、布尔为 false、指针为 nil 等。

##### 1) 键值对初始化结构体的书写格式

键值对初始化的格式如下：
```cgo
ins := 结构体类型名{
    字段1: 字段1的值,
    字段2: 字段2的值,
    …
}
```
下面是对各个部分的说明：
> 1. 结构体类型：定义结构体时的类型名称。
> 2. 字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。
> 3. 字段1的值、字段2的值：结构体成员字段的初始值。

键值之间以:分隔，键值对之间以,分隔。

##### 2) 使用键值对填充结构体的例子
下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下：
```cgo
type People struct {
    name  string
    child *People
}

relation := &People{
    name: "爷爷",
    child: &People{
        name: "爸爸",
        child: &People{
                name: "我",
        },
    },
}

代码说明如下：
第 198 行，定义 People 结构体。
第 199 行，结构体的字符串字段。
第 200 行，结构体的结构体指针字段，类型是 *People。
第 203 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。
第 305 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。

```
提示：
> 结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。

#### 使用多个值的列表初始化结构体
> Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。
##### 1) 多个值列表初始化结构体的书写格式
多个值使用逗号分隔初始化结构体，例如：
```cgo
ins := 结构体类型名{
    字段1的值,
    字段2的值,
    …
}
```
使用这种格式初始化时，需要注意：
> 1. 必须初始化结构体的所有字段。
> 2. 每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。
> 3. 键值对与值列表的初始化形式不能混用。

##### 2) 多个值列表初始化结构体的例子
下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如：
```cgo
type Address struct {
    Province    string
    City        string
    ZipCode     int
    PhoneNumber string
}

addr := Address{
    "四川",
    "成都",
    610000,
    "0",
}

fmt.Println(addr)


运行代码，输出如下：
{四川 成都 610000 0}
```
#### 初始化匿名结构体
> 匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。
##### 1) 匿名结构体定义格式和初始化写法
> 匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：
```cgo
ins := struct {
    // 匿名结构体字段定义
    字段1 字段类型1
    字段2 字段类型2
    …
}{
    // 字段值初始化
    初始化字段1: 字段1的值,
    初始化字段2: 字段2的值,
    …
}
```
下面是对各个部分的说明：
> 1. 字段1、字段2……：结构体定义的字段名。
> 2. 初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。
> 3. 字段类型1、字段类型2……：结构体定义字段的类型。
> 4. 字段1的值、字段2的值……：结构体初始化字段的初始值。

键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：
```cgo
ins := struct {
    字段1 字段类型1
    字段2 字段类型2
    …
}
```
##### 2) 使用匿名结构体的例子
> 在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：
```cgo
package main

import (
    "fmt"
)

// 打印消息类型, 传入匿名结构体
func printMsgType(msg *struct {
    id   int
    data string
}) {

    // 使用动词%T打印msg的类型
    fmt.Printf("%T\n", msg)
}

func main() {

    // 实例化一个匿名结构体
    msg := &struct {  // 定义部分
        id   int
        data string
    }{  // 值初始化部分
        1024,
        "hello",
    }

    printMsgType(msg)
}

代码输出如下：
*struct { id int; data string }

代码说明如下：
第 304 行，定义 printMsgType() 函数，参数为 msg，类型为*struct{id int data string}，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。
第 310 行，使用字符串格式化中的%T动词，将 msg 的类型名打印出来。
第 316 行，对匿名结构体进行实例化，同时初始化成员。
第 317 和 318 行，定义匿名结构体的字段。
第 320 和 321 行，给匿名结构体字段赋予初始值。
第 324 行，将 msg 传入 printMsgType() 函数中进行函数调用。
```
匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。

### 构造函数
Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。

其他编程语言构造函数的一些常见功能及特性如下：
> 1. 每个类可以添加构造函数，多个构造函数使用函数重载实现。
> 2. 构造函数一般与类名同名，且没有返回值。
> 3. 构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。
> 4. 对于 C++ 来说，还有默认构造函数、拷贝构造函数等。

#### 多种方式创建和初始化结构体——模拟构造函数重载
> 如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：
```cgo
type Cat struct {
    Color string
    Name  string
}

func NewCatByName(name string) *Cat {
    return &Cat{
        Name: name,
    }
}

func NewCatByColor(color string) *Cat {
    return &Cat{
        Color: color,
    }
}

代码说明如下：
第 352 行定义 Cat 结构，包含颜色和名字字段。
第 357 行定义用名字构造猫结构的函数，返回 Cat 指针。
第 358 行取地址实例化猫的结构体。
第 359 行初始化猫的名字字段，忽略颜色字段。
第 363 行定义用颜色构造猫结构的函数，返回 Cat 指针。
```
在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。

#### 带有父子关系的结构体的构造和初始化——模拟父级构造调用
> 黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：
```cgo
type Cat struct {
    Color string
    Name  string
}

type BlackCat struct {
    Cat  // 嵌入Cat, 类似于派生
}

// “构造基类”
func NewCat(name string) *Cat {
    return &Cat{
        Name: name,
    }
}

// “构造子类”
func NewBlackCat(color string) *BlackCat {
    cat := &BlackCat{}
    cat.Color = color
    return cat
}

代码说明如下：
第 386 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。
第 391 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。
第 398 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。
第 399 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。
第 400 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。
```

这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。

总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。


### 方法和接收器
> 在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。

> 接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误invalid receiver type…。

> 接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。

> 类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。

> 因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。

提示
>在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。


#### 为结构体添加方法

> 本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。

##### 1) 面向过程实现方法
面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下：
```cgo
type Bag struct {
    items []int
}

// 将一个物品放入背包的过程
func Insert(b *Bag, itemid int) {
    b.items = append(b.items, itemid)
}

func main() {

    bag := new(Bag)

    Insert(bag, 1001)
}

代码说明如下：
第 439 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。
第 444 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。
第 445 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。
第 450 行，创建背包实例 bag。
第 452 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。
```
> Insert() 函数将 *Bag 参数放在第一位，强调 Insert 会操作 *Bag 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。

##### 2) Go语言的结构体方法
将背包及放入背包的物品中使用Go语言的结构体和方法方式编写，为 *Bag 创建一个方法，代码如下：
```cgo
type Bag struct {
    items []int
}

func (b *Bag) Insert(itemid int) {
    b.items = append(b.items, itemid)
}

func main() {

    b := new(Bag)

    b.Insert(1001)
}

第 471 行中，Insert(itemid int) 的写法与函数一致，(b*Bag) 表示接收器，即 Insert 作用的对象实例。
```

#### 接收器——方法作用的目标
接收器的格式如下：
```cgo
func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {
    函数体
}

对各部分的说明：
接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。
接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。
方法名、参数列表、返回参数：格式与函数定义一致。

```

接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。

##### 1) 理解指针类型的接收器
> 指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。

> 由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。

> 在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。

```cgo
package main

import "fmt"

// 定义属性结构
type Property struct {
    value int  // 属性值
}

// 设置属性值
func (p *Property) SetValue(v int) {

    // 修改p的成员变量
    p.value = v
}

// 取属性值
func (p *Property) Value() int {
    return p.value
}

func main() {

    // 实例化属性
    p := new(Property)

    // 设置值
    p.SetValue(100)

    // 打印值
    fmt.Println(p.Value())

}
```

##### 2) 理解非指针类型的接收器
> 当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。

> 点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。
```cgo
package main

import (
    "fmt"
)

// 定义点结构
type Point struct {
    X int
    Y int
}

// 非指针接收器的加方法
func (p Point) Add(other Point) Point {

    // 成员值与参数相加后返回新的结构
    return Point{p.X + other.X, p.Y + other.Y}
}

func main() {

    // 初始化点
    p1 := Point{1, 1}
    p2 := Point{2, 2}

    // 与另外一个点相加
    result := p1.Add(p2)

    // 输出结果
    fmt.Println(result)

}
```
##### 3) 指针和非指针接收器的使用
在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。

#### 示例：二维矢量模拟玩家移动
在游戏中，一般使用二维矢量保存玩家的位置，使用矢量运算可以计算出玩家移动的位置，本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。

##### 1) 实现二维矢量结构
> 矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算，在计算机中，使用拥有 X 和 Y 两个分量的 Vec2 结构体实现数学中二维向量的概念，详细实现请参考下面的代码。
```cgo
package main

import "math"

type Vec2 struct {
    X, Y float32
}

// 加
func (v Vec2) Add(other Vec2) Vec2 {

    return Vec2{
        v.X + other.X,
        v.Y + other.Y,
    }

}

// 减
func (v Vec2) Sub(other Vec2) Vec2 {

    return Vec2{
        v.X - other.X,
        v.Y - other.Y,
    }
}

// 乘
func (v Vec2) Scale(s float32) Vec2 {

    return Vec2{v.X * s, v.Y * s}
}

// 距离
func (v Vec2) DistanceTo(other Vec2) float32 {
    dx := v.X - other.X
    dy := v.Y - other.Y

    return float32(math.Sqrt(float64(dx*dx + dy*dy)))
}

// 插值
func (v Vec2) Normalize() Vec2 {
    mag := v.X*v.X + v.Y*v.Y
    if mag > 0 {
        oneOverMag := 1 / float32(math.Sqrt(float64(mag)))
        return Vec2{v.X * oneOverMag, v.Y * oneOverMag}
    }

    return Vec2{0, 0}
}

代码说明如下：
第 595 行声明了一个 Vec2 结构体，包含两个方向的单精度浮点数作为成员。
第 600～605 行定义了 Vec2 的 Add() 方法，使用自身 Vec2 和通过 Add() 方法传入的 Vec2 进行相加，相加后，结果以返回值形式返回，不会修改 Vec2 的成员。
第 610 行定义了 Vec2 的减法操作。
第 619 行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale() 方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。
第 625 行定义了计算两个矢量的距离，math.Sqrt() 是开方函数，参数是 float64，在使用时需要转换，返回值也是 float64，需要转换回 float32。
第 633 行定义矢量单位化。
```

##### 2) 实现玩家对象
> 玩家对象负责存储玩家的当前位置、目标位置和速度，使用 MoveTo() 方法为玩家设定移动的目标，使用 Update() 方法更新玩家位置，在 Update() 方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。

图解释:  http://c.biancheng.net/view/69.html
下面是玩家对象的具体代码：
```cgo
package main

type Player struct {
    currPos   Vec2    // 当前位置
    targetPos Vec2    // 目标位置
    speed     float32 // 移动速度
}

// 移动到某个点就是设置目标位置
func (p *Player) MoveTo(v Vec2) {

    p.targetPos = v
}

// 获取当前的位置
func (p *Player) Pos() Vec2 {
    return p.currPos
}

// 是否到达
func (p *Player) IsArrived() bool {

    // 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点
    return p.currPos.DistanceTo(p.targetPos) < p.speed
}

// 逻辑更新
func (p *Player) Update() {

    if !p.IsArrived() {

        // 计算出当前位置指向目标的朝向
        dir := p.targetPos.Sub(p.currPos).Normalize()

        // 添加速度矢量生成新的位置
        newPos := p.currPos.Add(dir.Scale(p.speed))

        // 移动完成后，更新当前位置
        p.currPos = newPos
    }

}

// 创建新玩家
func NewPlayer(speed float32) *Player {

    return &Player{
        speed: speed,
    }
}

代码说明如下：
第 660 行，结构体 Player 定义了一个玩家的基本属性和方法，结构体的 currPos 表示当前位置，speed 表示速度。
第 667 行，定义玩家的移动方法，逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由 Update() 方法负责。
第 673 行，使用 Pos 方法实现玩家 currPos 的属性访问封装。
第 678 行，判断玩家是否到达目标点，玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。
第 685 行，玩家移动时位置更新的主要实现。
第 687 行，如果已经到达，则不必再更新。
第 690 行，数学中，两矢量相减将获得指向被减矢量的新矢量，Sub() 方法返回的新矢量使用 Normalize() 方法单位化，最终返回的 dir 矢量就是移动方向。
第 693 行，在当前的位置上叠加根据速度缩放的方向计算出新的位置 newPos。
第 696 行，将新位置更新到 currPos，为下一次移动做准备。
第 702 行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。
```

##### 3) 处理移动逻辑
> 将 Player 实例化后，设定玩家移动的最终目标点，之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码所示：
```cgo
package main

import "fmt"

func main() {

    // 实例化玩家对象，并设速度为0.5
    p := NewPlayer(0.5)

    // 让玩家移动到3,1点
    p.MoveTo(Vec2{3, 1})

    // 如果没有到达就一直循环
    for !p.IsArrived() {

        // 更新玩家位置
        p.Update()

        // 打印每次移动后的玩家位置
        fmt.Println(p.Pos())
    }

}

代码说明如下：
第 732 行，使用 NewPlayer() 函数构造一个 *Player 玩家对象，并设移动速度为 0.5，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。
第 735 行，设定玩家移动的最终目标为 X 为 3，Y 为 1。
第 738 行，构造一个循环，条件是没有到达时一直循环。
第 741 行，不停地更新玩家位置，如果玩家到达目标，p.IsArrived 将会变为 true。
第 744 行，打印每次更新后玩家的位置。
```
 本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。

### 为任意类型添加方法
> Go语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。

#### 为基本类型添加方法
> 在Go语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如：
```cgo
if  v == 0 {
    // v等于0
}
```
如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如：
```cgo
if  v.IsZero() {
    // v等于0
}
```
为基本类型添加方法的详细实现流程如下：
```cgo
package main

import (
    "fmt"
)

// 将int定义为MyInt类型
type MyInt int

// 为MyInt添加IsZero()方法
func (m MyInt) IsZero() bool {
    return m == 0
}

// 为MyInt添加Add()方法
func (m MyInt) Add(other int) int {
    return other + int(m)
}

func main() {

    var b MyInt

    fmt.Println(b.IsZero())

    b = 1

    fmt.Println(b.Add(2))
}
```

























