## 整数
> 数值类型分为以下几种：
1. 整数
    1. 有符号整数包含: int8、int16、int32、int64 
    2. 无符号整数包含: uint8、uint16、uint32、uint64
    3. 特殊两个类型,int与uint
        1. 分别对应特定CPU, 平台的字长（机器字大小）
        2. 其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化
2. 浮点数 
    1. 两种精度的浮点数 float32 和 float64
    2. 一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大
3. 复数

>> 用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的
>> byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数

> 还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方
```
尽管在某些特定的运行环境下 int、uint 和 uintptr 的大小可能相等，但是它们依然是不同的类型，比如 int 和 int32，虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。

Go语言中有符号整数采用 2 的补码形式表示，也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2(n-1) 到 2(n-1)-1。无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2n-1。例如，int8 类型整数的取值范围是从 -128 到 127，而 uint8 类型整数的取值范围是从 0 到 255
```
---> 哪些情况下使用int和uint
> 程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用 int 来表示。
反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint

* 用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数
```
package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}

3.141593
3.14
```
---> 复数
* 在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）
* Go语言中复数的类型有两种，分别是  complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型
* 复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位

> 声明复数的语法格式：
>> var name complex128 = comple(x, y)
* 其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部
--> 简短声明
>> name := complex(x, y)
* 对于一个复数z := complex(x, y)，可以通过Go语言的内置函数real(z) 来获得该复数的实部，也就是 x；通过imag(z) 获得该复数的虚部，也就是 y
> 实例
```
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```
* 如果大家对复数的运算法则不是很了解，可以查阅《复数运算法则》，其中详细的讲解了复数的加减乘除操作。
* 复数也可以用==和!=进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的
* Go语言内置的 math/cmplx 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数

## 正弦图像
* 在Go语言中，正弦函数由 math 包提供，函数入口为 math.Sin，正弦函数的参数为 float64，返回值也是 float64。在使用正弦函数时，根据实际精度可以进行转换

